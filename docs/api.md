# API Documentation

## Overview

The Orb Integration Hub exposes a GraphQL API through AWS AppSync. The API provides CRUD operations for managing users, organizations, applications, roles, notifications, privacy requests, and ownership transfers.

All operations are auto-generated by `orb-schema-generator` from YAML schema definitions in `schemas/tables/`.

## Authentication

All API operations require Cognito User Pool authentication with group-based authorization.

### User Identity Model

**CRITICAL CONCEPT**: ALL users in the system are stored in the **Users** table. Everyone is a **User**. The distinction between different user types comes from:

1. **Cognito Groups** - Which group(s) a user belongs to (stored in the `groups` array field)
2. **Relationships** - Which organizations/applications they're associated with (via OrganizationUsers and ApplicationUserRoles tables)

The Users table is the single source of truth for ALL user identities, regardless of their role in the system.

### Cognito Groups Model

**Every user has AT LEAST the USER group** - it's the baseline for all authenticated users.

**Groups are additive and stored in an array** - a user can have multiple groups simultaneously:
- Platform Owner: `["USER", "OWNER"]` or `["USER", "CUSTOMER", "OWNER"]`
- Platform Employee: `["USER", "EMPLOYEE"]` or `["USER", "CUSTOMER", "EMPLOYEE"]`
- Customer (paying): `["USER", "CUSTOMER"]`
- End User (non-paying): `["USER"]`

**CUSTOMER group is tied to payment status**:
- Added when user subscribes/pays for platform
- Removed when subscription is cancelled
- Enables creating and owning organizations

### User Types Summary

| User Type | Cognito Group(s) | Description | Stored In | Relationships |
|-----------|------------------|-------------|-----------|---------------|
| **Platform Owner** | OWNER (+ USER, CUSTOMER optional) | User with full administrative access to platform | Users table | Can optionally have organization/application relationships |
| **Platform Employee** | EMPLOYEE (+ USER, CUSTOMER optional) | User who is internal team member | Users table | Can optionally have organization/application relationships |
| **Customer** | USER + CUSTOMER | User who is paying for platform subscription - can create organizations | Users table | OrganizationUsers → OWNER role in their organization(s)<br>Can also be EMPLOYEE in other organizations |
| **End User** | USER only | User with basic authenticated access - not paying for platform | Users table | OrganizationUsers → EMPLOYEE role in organizations<br>ApplicationUserRoles → permissions per environment |

**Key Points:** 
- Everyone is a **User** (stored in Users table)
- **Every user has at LEAST the USER group** - it's the baseline
- Cognito Groups are stored in the `groups` array field - **a user can have multiple groups**
- Groups are additive: USER is baseline, then CUSTOMER/EMPLOYEE/OWNER can be added
- CUSTOMER group is added when user pays for subscription, removed when they cancel

### Cognito Groups Reference

Operations specify required groups via the `@aws_auth` directive:

| Group | Description | How It's Assigned |
|-------|-------------|-------------------|
| USER | Basic authenticated user access | Assigned to ALL users at registration (baseline) |
| CUSTOMER | Customer-level access (managing organizations) | Added when user subscribes/pays for platform |
| EMPLOYEE | Internal employee access | Manually assigned to platform team members |
| OWNER | Full administrative access to platform | Manually assigned to platform owners |

### OrganizationUsers Roles

When users are members of organizations (via OrganizationUsers table), they have organizational roles:

| Role | Description | How It's Assigned |
|------|-------------|-------------------|
| OWNER | Owner of the organization | Automatically assigned when CUSTOMER creates an organization |
| EMPLOYEE | Employee/member of the organization | Assigned when organization OWNER invites them |

**Note**: OrganizationUsers roles are separate from Cognito groups. A user with only USER Cognito group can be an EMPLOYEE in an organization.

### Public Operations (API Key Authentication)

Some operations are accessible without user authentication using API key:

| Operation | Description |
|-----------|-------------|
| `CheckEmailExists` | Check if an email exists in the system |
| `CreateUserFromCognito` | Create user record from Cognito data during self-registration |

## Public Queries

### CheckEmailExists

Check if an email address exists in the system. This is a Lambda-backed query that uses API key authentication, allowing unauthenticated users to check email existence during the authentication flow.

**Authentication**: API Key (`@aws_api_key`)

**Input**:
```graphql
input CheckEmailExistsInput {
  email: String!
}
```

**Output**:
```graphql
type CheckEmailExists {
  email: String!
  exists: Boolean!
}
```

**Example**:
```graphql
query {
  CheckEmailExists(input: { email: "user@example.com" }) {
    email
    exists
  }
}
```

**Error Responses**:

| Error Code | Message | Description |
|------------|---------|-------------|
| ORB-AUTH-007 | Invalid email format | Email doesn't match expected format |
| ORB-API-005 | Email check service unavailable | Backend service error |

**Security Notes**:
- Returns only boolean existence status (no user data exposed)
- Email format validated before database query
- All requests logged for security audit

## Public Mutations

### CreateUserFromCognito

Create a user record in DynamoDB from Cognito data during self-registration. This is a secure, Lambda-backed mutation that validates against Cognito before creating records. Only accepts `cognitoSub` as input and extracts all user data from Cognito to prevent client-side data injection.

**Authentication**: API Key (`@aws_api_key`)

**Input**:
```graphql
input CreateUserFromCognitoInput {
  cognitoSub: String!
}
```

**Output**:
```graphql
type CreateUserFromCognito {
  cognitoSub: String!
  userId: String
  email: String
  firstName: String
  lastName: String
  status: String
  emailVerified: Boolean
  phoneVerified: Boolean
  mfaEnabled: Boolean
  mfaSetupComplete: Boolean
  groups: [String]
  createdAt: AWSTimestamp
  updatedAt: AWSTimestamp
}
```

**Example**:
```graphql
mutation {
  CreateUserFromCognito(input: { cognitoSub: "550e8400-e29b-41d4-a716-446655440000" }) {
    userId
    email
    firstName
    lastName
    status
    groups
  }
}
```

**Error Responses**:

| Error Code | Message | Description |
|------------|---------|-------------|
| ORB-AUTH-010 | Authentication service unavailable | Cognito service error |
| ORB-AUTH-011 | Invalid request format | cognitoSub is not a valid UUID |
| ORB-AUTH-012 | User not found | User doesn't exist in Cognito |
| ORB-API-010 | Database service unavailable | DynamoDB service error |

**Security Notes**:
- Only accepts `cognitoSub` as input - all other user data is extracted from Cognito
- Validates user exists in Cognito before creating DynamoDB record
- Idempotent - returns existing user if already created
- Timing attack prevention via consistent response times
- Error messages don't expose internal details or PII

**Use Case**:
This mutation is used during the self-registration flow after MFA verification. The frontend calls this mutation with the user's Cognito sub to create the corresponding DynamoDB record. This approach:
1. Prevents client-side data injection (all data comes from Cognito)
2. Ensures user exists in Cognito before creating DynamoDB record
3. Provides idempotency for retry scenarios

## Generated Operations

The schema contains 99 operations across 11 entities. Operations follow a consistent naming pattern:
- Queries: `{Entity}QueryBy{Key}` or `{Entity}QueryBy{Key}And{SortKey}`
- Mutations: `{Entity}Create`, `{Entity}Update`, `{Entity}Delete`, `{Entity}Disable`

### Users

**Queries** (Groups: CUSTOMER, EMPLOYEE, OWNER, USER):
- `UsersQueryByUserId(input: UsersQueryByUserIdInput!): UsersResponse`
- `UsersQueryByEmail(input: UsersQueryByEmailInput!): UsersResponse`
- `UsersQueryByCognitoId(input: UsersQueryByCognitoIdInput!): UsersResponse`
- `UsersQueryByCognitoSub(input: UsersQueryByCognitoSubInput!): UsersResponse`

**Mutations**:
- `UsersCreate(input: UsersCreateInput!): UsersResponse` (Groups: EMPLOYEE, OWNER) - Admin user creation
- `UsersUpdate(input: UsersUpdateInput!): UsersResponse` (Groups: EMPLOYEE, OWNER, or API Key)
- `UsersDelete(input: UsersDeleteInput!): UsersResponse` (Groups: EMPLOYEE, OWNER)
- `UsersDisable(input: UsersDisableInput!): UsersResponse` (Groups: EMPLOYEE, OWNER)

**Note**: For self-registration, use `CreateUserFromCognito` mutation instead of `UsersCreate`. The `UsersCreate` mutation is restricted to admin operations (EMPLOYEE, OWNER groups).

### Organizations

**Queries** (Groups: CUSTOMER, EMPLOYEE, OWNER):
- `OrganizationsQueryByOrganizationId(input: OrganizationsQueryByOrganizationIdInput!): OrganizationsResponse`
- `OrganizationsQueryByOwnerId(input: OrganizationsQueryByOwnerIdInput!): OrganizationsResponse`
- `OrganizationsQueryByOwnerIdAndCreatedAt(input: OrganizationsQueryByOwnerIdAndCreatedAtInput!): OrganizationsResponse`
- `OrganizationsQueryByStatus(input: OrganizationsQueryByStatusInput!): OrganizationsResponse`
- `OrganizationsQueryByStatusAndCreatedAt(input: OrganizationsQueryByStatusAndCreatedAtInput!): OrganizationsResponse`

**Mutations** (Groups: CUSTOMER, EMPLOYEE, OWNER):
- `OrganizationsCreate(input: OrganizationsCreateInput!): OrganizationsResponse`
- `OrganizationsUpdate(input: OrganizationsUpdateInput!): OrganizationsResponse`
- `OrganizationsDelete(input: OrganizationsDeleteInput!): OrganizationsResponse`
- `OrganizationsDisable(input: OrganizationsDisableInput!): OrganizationsResponse`

### Applications

**Queries** (Groups: CUSTOMER, EMPLOYEE, OWNER):
- `ApplicationsQueryByApplicationId(input: ApplicationsQueryByApplicationIdInput!): ApplicationsResponse`
- `ApplicationsQueryByOrganizationId(input: ApplicationsQueryByOrganizationIdInput!): ApplicationsResponse`
- `ApplicationsQueryByOrganizationIdAndCreatedAt(input: ApplicationsQueryByOrganizationIdAndCreatedAtInput!): ApplicationsResponse`

**Mutations** (Groups: CUSTOMER, EMPLOYEE, OWNER):
- `ApplicationsCreate(input: ApplicationsCreateInput!): ApplicationsResponse`
- `ApplicationsUpdate(input: ApplicationsUpdateInput!): ApplicationsResponse`
- `ApplicationsDelete(input: ApplicationsDeleteInput!): ApplicationsResponse`
- `ApplicationsDisable(input: ApplicationsDisableInput!): ApplicationsResponse`

### Organization Users

**Queries** (Groups: CUSTOMER, EMPLOYEE, OWNER):
- `OrganizationUsersQueryByUserId(input: OrganizationUsersQueryByUserIdInput!): OrganizationUsersResponse`
- `OrganizationUsersQueryByOrganizationId(input: OrganizationUsersQueryByOrganizationIdInput!): OrganizationUsersResponse`
- `OrganizationUsersQueryByUserIdAndOrganizationId(input: OrganizationUsersQueryByUserIdAndOrganizationIdInput!): OrganizationUsersResponse`
- `OrganizationUsersQueryByOrganizationIdAndRole(input: OrganizationUsersQueryByOrganizationIdAndRoleInput!): OrganizationUsersResponse`
- `OrganizationUsersQueryByUserIdAndRole(input: OrganizationUsersQueryByUserIdAndRoleInput!): OrganizationUsersResponse`

**Mutations** (Groups: CUSTOMER, EMPLOYEE, OWNER):
- `OrganizationUsersCreate(input: OrganizationUsersCreateInput!): OrganizationUsersResponse`
- `OrganizationUsersUpdate(input: OrganizationUsersUpdateInput!): OrganizationUsersResponse`
- `OrganizationUsersDelete(input: OrganizationUsersDeleteInput!): OrganizationUsersResponse`
- `OrganizationUsersDisable(input: OrganizationUsersDisableInput!): OrganizationUsersResponse`

### Notifications

**Queries** (Groups: CUSTOMER, EMPLOYEE, OWNER):
- `NotificationsQueryByNotificationId(input: NotificationsQueryByNotificationIdInput!): NotificationsResponse`
- `NotificationsQueryByRecipientUserId(input: NotificationsQueryByRecipientUserIdInput!): NotificationsResponse`
- `NotificationsQueryByRecipientUserIdAndCreatedAt(input: NotificationsQueryByRecipientUserIdAndCreatedAtInput!): NotificationsResponse`
- `NotificationsQueryByType(input: NotificationsQueryByTypeInput!): NotificationsResponse`
- `NotificationsQueryByTypeAndStatus(input: NotificationsQueryByTypeAndStatusInput!): NotificationsResponse`

**Mutations** (Groups: CUSTOMER, EMPLOYEE, OWNER):
- `NotificationsCreate(input: NotificationsCreateInput!): NotificationsResponse`
- `NotificationsUpdate(input: NotificationsUpdateInput!): NotificationsResponse`
- `NotificationsDelete(input: NotificationsDeleteInput!): NotificationsResponse`
- `NotificationsDisable(input: NotificationsDisableInput!): NotificationsResponse`

### Privacy Requests

**Queries** (Groups: EMPLOYEE, OWNER):
- `PrivacyRequestsQueryByRequestId(input: PrivacyRequestsQueryByRequestIdInput!): PrivacyRequestsResponse`
- `PrivacyRequestsQueryByRequestType(input: PrivacyRequestsQueryByRequestTypeInput!): PrivacyRequestsResponse`
- `PrivacyRequestsQueryByRequestTypeAndReceivedAt(input: PrivacyRequestsQueryByRequestTypeAndReceivedAtInput!): PrivacyRequestsResponse`
- `PrivacyRequestsQueryByDataSubjectEmail(input: PrivacyRequestsQueryByDataSubjectEmailInput!): PrivacyRequestsResponse`
- `PrivacyRequestsQueryByDataSubjectEmailAndReceivedAt(input: PrivacyRequestsQueryByDataSubjectEmailAndReceivedAtInput!): PrivacyRequestsResponse`
- `PrivacyRequestsQueryByOrganizationId(input: PrivacyRequestsQueryByOrganizationIdInput!): PrivacyRequestsResponse`
- `PrivacyRequestsQueryByOrganizationIdAndReceivedAt(input: PrivacyRequestsQueryByOrganizationIdAndReceivedAtInput!): PrivacyRequestsResponse`
- `PrivacyRequestsQueryByStatus(input: PrivacyRequestsQueryByStatusInput!): PrivacyRequestsResponse`
- `PrivacyRequestsQueryByStatusAndDeadline(input: PrivacyRequestsQueryByStatusAndDeadlineInput!): PrivacyRequestsResponse`

**Mutations** (Groups: EMPLOYEE, OWNER):
- `PrivacyRequestsCreate(input: PrivacyRequestsCreateInput!): PrivacyRequestsResponse`
- `PrivacyRequestsUpdate(input: PrivacyRequestsUpdateInput!): PrivacyRequestsResponse`
- `PrivacyRequestsDelete(input: PrivacyRequestsDeleteInput!): PrivacyRequestsResponse`
- `PrivacyRequestsDisable(input: PrivacyRequestsDisableInput!): PrivacyRequestsResponse`

### Ownership Transfer Requests

**Queries** (Groups: CUSTOMER, EMPLOYEE, OWNER):
- `OwnershipTransferRequestsQueryByTransferId(input: OwnershipTransferRequestsQueryByTransferIdInput!): OwnershipTransferRequestsResponse`
- `OwnershipTransferRequestsQueryByCurrentOwnerId(input: OwnershipTransferRequestsQueryByCurrentOwnerIdInput!): OwnershipTransferRequestsResponse`
- `OwnershipTransferRequestsQueryByCurrentOwnerIdAndCreatedAt(input: OwnershipTransferRequestsQueryByCurrentOwnerIdAndCreatedAtInput!): OwnershipTransferRequestsResponse`
- `OwnershipTransferRequestsQueryByNewOwnerId(input: OwnershipTransferRequestsQueryByNewOwnerIdInput!): OwnershipTransferRequestsResponse`
- `OwnershipTransferRequestsQueryByNewOwnerIdAndCreatedAt(input: OwnershipTransferRequestsQueryByNewOwnerIdAndCreatedAtInput!): OwnershipTransferRequestsResponse`
- `OwnershipTransferRequestsQueryByStatus(input: OwnershipTransferRequestsQueryByStatusInput!): OwnershipTransferRequestsResponse`
- `OwnershipTransferRequestsQueryByStatusAndCreatedAt(input: OwnershipTransferRequestsQueryByStatusAndCreatedAtInput!): OwnershipTransferRequestsResponse`
- `OwnershipTransferRequestsQueryByStatusAndExpiresAt(input: OwnershipTransferRequestsQueryByStatusAndExpiresAtInput!): OwnershipTransferRequestsResponse`

**Mutations** (Groups: CUSTOMER, EMPLOYEE, OWNER):
- `OwnershipTransferRequestsCreate(input: OwnershipTransferRequestsCreateInput!): OwnershipTransferRequestsResponse`
- `OwnershipTransferRequestsUpdate(input: OwnershipTransferRequestsUpdateInput!): OwnershipTransferRequestsResponse`
- `OwnershipTransferRequestsDelete(input: OwnershipTransferRequestsDeleteInput!): OwnershipTransferRequestsResponse`
- `OwnershipTransferRequestsDisable(input: OwnershipTransferRequestsDisableInput!): OwnershipTransferRequestsResponse`

### Application Users

**GetApplicationUsers** (Groups: CUSTOMER, EMPLOYEE, OWNER)

Query application users with filtering, authorization, and enrichment. This is a Lambda-backed query that provides complex filtering logic and user deduplication.

**Input**:
```graphql
input GetApplicationUsersInput {
  organizationIds: [String!]  # Optional: filter by organizations
  applicationIds: [String!]   # Optional: filter by applications
  environment: Environment    # Optional: filter by environment (requires org or app filter)
  limit: Int                  # Optional: pagination limit (default: 50, max: 100)
  nextToken: String           # Optional: pagination token
}
```

**Output**:
```graphql
type GetApplicationUsersOutput {
  users: [UserWithRoles!]!
  nextToken: String
}

type UserWithRoles {
  userId: String!
  firstName: String!
  lastName: String!
  status: UserStatus!
  roleAssignments: [RoleAssignment!]!
}

type RoleAssignment {
  applicationUserRoleId: String!
  applicationId: String!
  applicationName: String!
  organizationId: String!
  organizationName: String!
  environment: Environment!
  roleId: String!
  roleName: String!
  permissions: [String!]!
  status: ApplicationUserRoleStatus!
  createdAt: AWSTimestamp!
  updatedAt: AWSTimestamp!
}
```

**Example - Query all users**:
```graphql
query {
  GetApplicationUsers(input: { limit: 50 }) {
    users {
      userId
      firstName
      lastName
      status
      roleAssignments {
        applicationName
        environment
        roleName
        permissions
      }
    }
    nextToken
  }
}
```

**Example - Filter by application and environment**:
```graphql
query {
  GetApplicationUsers(input: {
    applicationIds: ["app-123"]
    environment: PRODUCTION
    limit: 25
  }) {
    users {
      userId
      firstName
      lastName
      roleAssignments {
        roleName
        permissions
      }
    }
  }
}
```

**Error Responses**:

| Error Code | Message | Description |
|------------|---------|-------------|
| ORB-VAL-001 | Environment filter requires organizationIds or applicationIds | Environment filter provided without org/app filter |
| ORB-VAL-002 | Limit must be between 1 and 100 | Invalid limit value |
| ORB-VAL-003 | Invalid environment value | Environment not in allowed enum values |
| ORB-AUTH-001 | Authentication required | No authentication token provided |
| ORB-AUTH-002 | Invalid authentication token | Token validation failed |
| ORB-AUTH-003 | Insufficient permissions | User lacks required group membership |
| ORB-DB-001 | Database query failed | DynamoDB query error |
| ORB-DB-002 | Failed to retrieve user details | User enrichment batch get failed |

**Authorization Behavior**:
- CUSTOMER users: Only see users in organizations they own
- EMPLOYEE/OWNER users: See users across all organizations

**Query Strategy**:
- With `applicationIds`: Uses AppEnvUserIndex GSI (most efficient)
- With `organizationIds` only: Resolves to applications, then queries
- No filters: Returns all accessible users based on authorization

**Notes**:
- Users are deduplicated by userId with all role assignments grouped
- Results are sorted by lastName, then firstName
- Email addresses are excluded from output (PII protection)

### Additional Entities

See `apps/api/graphql/schema.graphql` for complete operations on:
- ApplicationRoles (OWNER only)
- Roles (OWNER only)
- SmsRateLimit (OWNER, USER)

## Response Types

All operations return a paginated response:

```graphql
type UsersResponse {
  items: [Users!]
  nextToken: String
}
```

## Input Types

Query inputs include the key field(s) and pagination:

```graphql
input UsersQueryByEmailInput {
  email: String!
  limit: Int
  nextToken: String
}
```

Create/Update inputs include all entity fields:

```graphql
input UsersCreateInput {
  userId: String!
  cognitoId: String!
  email: String!
  firstName: String!
  lastName: String!
  status: UserStatus!
  # ... additional fields
}
```

## Error Handling

See [Error Handling Documentation](./error-handling.md) for detailed error codes and handling patterns.

## Schema Reference

The complete GraphQL schema is generated at `apps/api/graphql/schema.graphql`.

To regenerate after schema changes:
```bash
pipenv run orb-schema generate
```

## Environment Configuration API

The Environment Configuration API allows managing per-environment settings for applications including CORS origins, rate limits, webhooks, and feature flags.

### Types

```graphql
type ApplicationEnvironmentConfig {
  applicationId: String!
  environment: Environment!
  organizationId: String!
  allowedOrigins: [String!]
  rateLimitPerMinute: Int!
  rateLimitPerDay: Int!
  webhookUrl: String
  webhookSecret: String
  webhookEvents: [String!]
  webhookEnabled: Boolean!
  webhookMaxRetries: Int
  webhookRetryDelaySeconds: Int
  featureFlags: AWSJSON
  metadata: AWSJSON
  createdAt: AWSTimestamp!
  updatedAt: AWSTimestamp!
}
```

### Queries

**GetApplicationEnvironmentConfig** (Groups: CUSTOMER, EMPLOYEE, OWNER)

Get environment configuration for an application.

```graphql
query {
  GetApplicationEnvironmentConfig(
    applicationId: "app-123"
    environment: DEVELOPMENT
  ) {
    applicationId
    environment
    allowedOrigins
    rateLimitPerMinute
    rateLimitPerDay
    webhookEnabled
    featureFlags
  }
}
```

### Mutations

**UpdateApplicationEnvironmentConfig** (Groups: CUSTOMER, EMPLOYEE, OWNER)

Update environment configuration settings.

```graphql
mutation {
  UpdateApplicationEnvironmentConfig(input: {
    applicationId: "app-123"
    environment: DEVELOPMENT
    rateLimitPerMinute: 120
    rateLimitPerDay: 20000
  }) {
    applicationId
    environment
    rateLimitPerMinute
    rateLimitPerDay
    updatedAt
  }
}
```

**AddAllowedOrigin** (Groups: CUSTOMER, EMPLOYEE, OWNER)

Add a CORS origin to the allowed list.

```graphql
mutation {
  AddAllowedOrigin(input: {
    applicationId: "app-123"
    environment: DEVELOPMENT
    origin: "https://app.example.com"
  }) {
    applicationId
    allowedOrigins
  }
}
```

**RemoveAllowedOrigin** (Groups: CUSTOMER, EMPLOYEE, OWNER)

Remove a CORS origin from the allowed list.

```graphql
mutation {
  RemoveAllowedOrigin(input: {
    applicationId: "app-123"
    environment: DEVELOPMENT
    origin: "https://old-app.example.com"
  }) {
    applicationId
    allowedOrigins
  }
}
```

**UpdateWebhookConfig** (Groups: CUSTOMER, EMPLOYEE, OWNER)

Update webhook configuration.

```graphql
mutation {
  UpdateWebhookConfig(input: {
    applicationId: "app-123"
    environment: PRODUCTION
    webhookUrl: "https://webhook.example.com/events"
    webhookEnabled: true
    webhookEvents: ["USER_CREATED", "USER_UPDATED", "USER_DELETED"]
    webhookMaxRetries: 5
    webhookRetryDelaySeconds: 120
  }) {
    applicationId
    webhookUrl
    webhookEnabled
    webhookEvents
  }
}
```

**RegenerateWebhookSecret** (Groups: CUSTOMER, EMPLOYEE, OWNER)

Generate a new webhook secret. The old secret is immediately invalidated.

```graphql
mutation {
  RegenerateWebhookSecret(input: {
    applicationId: "app-123"
    environment: PRODUCTION
  }) {
    webhookSecret
  }
}
```

**SetFeatureFlag** (Groups: CUSTOMER, EMPLOYEE, OWNER)

Set a feature flag value.

```graphql
mutation {
  SetFeatureFlag(input: {
    applicationId: "app-123"
    environment: DEVELOPMENT
    key: "new_feature_enabled"
    value: true
  }) {
    applicationId
    featureFlags
  }
}
```

**DeleteFeatureFlag** (Groups: CUSTOMER, EMPLOYEE, OWNER)

Delete a feature flag.

```graphql
mutation {
  DeleteFeatureFlag(input: {
    applicationId: "app-123"
    environment: DEVELOPMENT
    key: "deprecated_feature"
  }) {
    applicationId
    featureFlags
  }
}
```

## Dual API Key System

Applications support two types of API keys:

| Key Type | Prefix | Use Case | Origin Validation |
|----------|--------|----------|-------------------|
| Publishable | `pk_` | Client-side (browser, mobile) | Required |
| Secret | `sk_` | Server-side only | Not required |

### Key Generation

```graphql
mutation {
  GenerateApiKey(input: {
    applicationId: "app-123"
    organizationId: "org-456"
    environment: PRODUCTION
    keyType: PUBLISHABLE
  }) {
    applicationApiKeyId
    fullKey
    keyPrefix
    keyType
  }
}
```

**Important**: The `fullKey` is only returned once during generation. Store it securely.

### Key Validation

Publishable keys (`pk_*`) are validated against the configured allowed origins. Requests from non-allowed origins are rejected.

Secret keys (`sk_*`) bypass origin validation but should only be used in server-side code where the key cannot be exposed.

## Webhook Integration

### Event Types

| Event | Description |
|-------|-------------|
| `USER_CREATED` | A new user was created |
| `USER_UPDATED` | User data was modified |
| `USER_DELETED` | A user was deleted |
| `GROUP_CREATED` | A new group was created |
| `GROUP_UPDATED` | Group data was modified |
| `GROUP_DELETED` | A group was deleted |
| `ROLE_ASSIGNED` | A role was assigned to a user |
| `ROLE_REVOKED` | A role was revoked from a user |

### Webhook Payload

```json
{
  "eventId": "evt-550e8400-e29b-41d4-a716-446655440000",
  "eventType": "USER_CREATED",
  "timestamp": "2026-02-03T12:00:00Z",
  "applicationId": "app-123",
  "organizationId": "org-456",
  "environment": "PRODUCTION",
  "resource": {
    "type": "user",
    "id": "user-789"
  },
  "data": {
    "email": "user@example.com",
    "firstName": "John",
    "lastName": "Doe"
  },
  "actor": {
    "id": "admin-user-123"
  }
}
```

### Webhook Headers

| Header | Description |
|--------|-------------|
| `X-Webhook-Signature` | HMAC-SHA256 signature: `sha256={signature}` |
| `X-Webhook-Timestamp` | Unix timestamp of the request |
| `X-Webhook-Event` | Event type (e.g., `USER_CREATED`) |
| `Content-Type` | `application/json` |

### Signature Verification

Verify webhook signatures to ensure authenticity:

```python
import hmac
import hashlib

def verify_webhook(payload: str, secret: str, signature: str) -> bool:
    expected = hmac.new(
        secret.encode('utf-8'),
        payload.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    return hmac.compare_digest(f"sha256={expected}", signature)
```

### Retry Policy

Failed webhook deliveries are retried with exponential backoff:
- Default: 3 retries
- Configurable via `webhookMaxRetries` (max 10)
- Delay between retries configurable via `webhookRetryDelaySeconds`

After all retries are exhausted, the event is moved to a dead letter queue for manual inspection.
