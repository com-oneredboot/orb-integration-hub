# Frontend Design Plan - Orb Integration Hub

This document outlines the design principles, architecture, and key features for the Orb Integration Hub frontend.

## 1. Introduction & Goals

*   **Overview:** The frontend provides a web-based interface for interacting with and monitoring the Orb Integration Hub.
*   **Primary Goals:**
    *   Provide a UI for exploring the GraphQL API.
    *   Allow users to view generated data schemas/models.
    *   Offer insights into integration status and health (if applicable).
    *   (Add other specific goals as needed)

## 2. Target Audience

*   Developers integrating services with the Hub.
*   Administrators monitoring system health and usage.
*   Support teams troubleshooting integration issues.

## 3. Technology Stack

*   **Framework:** Angular (v19 indicated by dependencies)
*   **Language:** TypeScript
*   **UI Component Library:** PrimeNG
*   **State Management:** NgRx (v19 indicated by dependencies)
*   **GraphQL Client:** AWS Amplify API Client
*   **Styling:** SCSS (Standard Angular setup)
*   **Other Key Libs:** AWS Amplify

## 4. High-Level Architecture

*   **Modules:** Follow standard Angular module structure (AppModule, CoreModule, SharedModule, Feature Modules).
    *   *Potential Feature Modules:* DashboardModule, ApiExplorerModule, SchemaViewerModule, AuthModule.
*   **Component Structure:** Employ Smart/Container components for logic and state interaction, and Presentational/Dumb components for UI rendering.
*   **Services:** Centralize API calls, state logic (if not using a dedicated library), and reusable utility functions.
*   **Routing:** Utilize Angular Router for navigation between features/views.
*   **Generated Models:** Strictly use models generated by `schemas/generate.py` located in `frontend/src/models/` for type safety in API interactions and data display.

## 5. UI/UX Principles & Guidelines

*   **Consistency:** Maintain uniform layout, terminology, component usage, and interaction patterns.
*   **Clarity:** Ensure intuitive navigation, clear visual hierarchy, and informative user feedback (loading states, errors, successes).
*   **Responsiveness:** Design primarily for desktop use, but ensure basic usability on smaller screens.
*   **Accessibility (a11y):** Strive for WCAG AA compliance where applicable (semantic HTML, keyboard navigation, ARIA attributes).
*   **Performance:** Optimize for fast load times and smooth interactions (lazy loading modules, efficient change detection).

## 6. Key Views/Features (Initial Scope)

*   **Authentication:** Login View (Integration with backend auth).
*   **Main Layout:** Consistent Header (with navigation), Footer, potentially a Sidebar.
*   **Dashboard:** Overview page (if applicable).
*   **API Explorer:** Interface to execute GraphQL queries/mutations/subscriptions (e.g., using a library like `graphql-playground-angular` or a custom implementation).
*   **Schema Viewer:** View to display the structure of generated data models.
*   *(Add other views as needed, e.g., User Profile, Settings)*

## 7. State Management Strategy

*   Utilize NgRx for centralized state management, defining actions, reducers, effects, and selectors for relevant features.

## 8. API Integration Strategy

*   Configure AWS Amplify API client (likely in `main.ts` or `app.module.ts`).
*   Define GraphQL queries/mutations/subscriptions using Amplify conventions.
*   Implement robust error handling for Amplify API calls.
*   Leverage generated models with Amplify API results.

## 9. Styling Approach

*   Use SCSS for enhanced CSS capabilities.
*   Define a global stylesheet (`styles.scss`) for base styles, variables, and theme setup.
*   Use component-scoped styles for encapsulation.
*   Establish a clear directory structure for shared styles (e.g., `src/app/styles/`).
*   Integrate styles according to the chosen UI library's guidelines.

## 10. Testing Strategy

*   **Unit Testing:** Use Angular CLI's default Karma/Jasmine setup for testing services, pipes, and simple components.
*   **Integration Testing:** Test container components interacting with their dependencies (services, child components).
*   **End-to-End Testing (Optional):** Consider Cypress or Playwright for E2E testing later in the project lifecycle.

## 11. Future Considerations

*   Internationalization (i18n)
*   Theming capabilities
*   Advanced monitoring dashboards
*   Mobile optimization 