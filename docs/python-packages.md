# Python Package Architecture

## Overview

The ORB Integration Hub backend uses a modular Python package architecture to organize shared code and maintain clean dependencies. This approach replaces the previous Lambda layer-based architecture with standard Python packages.

## Package Structure

### orb-common
Location: `backend/packages/orb-common/`

The core utility package containing:
- **Exceptions**: Shared exception classes and error handling
- **Security**: Authentication helpers, token validation, encryption utilities
- **Audit**: Logging functionality, event tracking, compliance features
- **Utils**: General utility functions

### orb-models
Location: `backend/packages/orb-models/`

Auto-generated data models from schema definitions:
- **Models**: Pydantic models for all entities (Users, Organizations, etc.)
- **Enums**: Enumeration types (UserStatus, OrganizationRole, etc.)
- **Repository**: DynamoDB repository mappings

**Note**: This package is fully auto-generated by `schemas/generate.py`. Do not manually edit files in this package.

## Using Packages in Lambda Functions

### 1. Create a Pipfile
Each Lambda function should have its own Pipfile:

```toml
[[source]]
url = "https://pypi.org/simple"
verify_ssl = true
name = "pypi"

[packages]
orb-common = {path = "../../../packages/orb-common", editable = true}
orb-models = {path = "../../../packages/orb-models", editable = true}
boto3 = "*"

[dev-packages]

[requires]
python_version = "3.12"
```

### 2. Import from Packages
```python
# Import exceptions
from orb_common.exceptions import ValidationError, ResourceNotFoundError

# Import security utilities
from orb_common.security import validate_token, encrypt_data

# Import models
from orb_models.models import User, Organization
from orb_models.enums import UserStatus
```

## Lambda Layer Architecture

Lambda layers are still used but only for packaging dependencies, not for sharing code between layers:

### Layer Structure
```
backend/src/layers/
├── organizations_security/   # Organization-specific security layer
├── users_security/          # User-specific security layer
└── stripe/                  # Stripe integration layer
```

Each layer:
- Has its own Pipfile listing dependencies (including orb-common/orb-models)
- Is built independently with all dependencies bundled
- Does NOT import from other layers

## Development Workflow

### 1. Adding New Shared Functionality

If you need to add new shared utilities:
1. Add them to the appropriate module in `orb-common`
2. Update the module's `__init__.py` to export new functions
3. Run tests to ensure functionality works correctly

### 2. Updating Models

Models are auto-generated:
1. Update the YAML schema files in `schemas/entities/`
2. Run `python generate.py` from the schemas directory
3. Models will be regenerated in the orb-models package

### 3. Installing Dependencies

For Lambda functions:
```bash
cd backend/src/lambdas/my-function
pipenv install
```

For Lambda layers:
```bash
cd backend/src/layers/my-layer
pipenv install
```

## Best Practices

### 1. Package Dependencies
- Keep orb-common lightweight with minimal external dependencies
- orb-models should only depend on pydantic and boto3
- Lambda-specific dependencies go in the Lambda's Pipfile

### 2. Import Organization
```python
# Good - specific imports
from orb_common.exceptions import ValidationError
from orb_models.models import User

# Avoid - wildcard imports
from orb_common import *
```

### 3. Version Management
- Packages use editable installs during development
- For production, consider pinning versions
- All packages within the monorepo move together

## Migration from Lambda Layers

The previous architecture used Lambda layers with direct imports:
```python
# Old approach - DON'T USE
from exceptions import ValidationError  # From common layer
```

The new approach uses package imports:
```python
# New approach - USE THIS
from orb_common.exceptions import ValidationError
```

## Testing

See [Testing Guidelines](./testing-guidelines.md) for information on testing packages and Lambda functions.

## CI/CD Considerations

1. **Build Order**: Packages don't need separate builds since they're used via editable installs
2. **Lambda Deployment**: Each Lambda function bundles its dependencies during deployment
3. **Layer Building**: The `build_layer.sh` script handles installing package dependencies

## Troubleshooting

### Import Errors
If you get import errors:
1. Ensure the Pipfile includes the required packages
2. Run `pipenv install` to install dependencies
3. Check that package paths in Pipfile are correct relative paths

### Model Not Found
If models are missing:
1. Run `python generate.py` in the schemas directory
2. Check that orb-models is in your Pipfile
3. Ensure you're importing from the correct module

### Package Not Installing
If packages won't install:
1. Check that the package has a proper `pyproject.toml`
2. Ensure relative paths in Pipfile are correct
3. Try `pipenv install --skip-lock` for debugging

## Code Quality Standards

All Python packages must maintain high code quality standards:

### Required Tools
- **Black**: Code formatter with line-length=100
- **isort**: Import organizer with black profile
- **mypy**: Type checker for Python 3.12
- **bandit**: Security vulnerability scanner
- **pytest**: Testing framework

### Package Configuration
Each package must have a `pyproject.toml` with proper tool configurations:

```toml
[tool.black]
line-length = 100
target-version = ['py312']

[tool.isort]
profile = "black"
line_length = 100

[tool.mypy]
python_version = "3.12"
disallow_untyped_defs = true
```

### CI/CD Integration
The `deploy-packages.yml` workflow automatically:
1. Runs all code quality checks
2. Builds packages only when changes are detected
3. Respects dependency order (orb-common → orb-models)
4. Fails the build if any quality check fails

### Development Workflow
```bash
# Before committing, run locally:
cd backend/packages/orb-common
black .
isort .
mypy orb_common --ignore-missing-imports
pytest
```