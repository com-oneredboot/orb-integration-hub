# --------------------------------------------------- #
AWSTemplateFormatVersion: 2010-09-09

# --------------------------------------------------- #
Transform: AWS::Serverless-2016-10-31

# --------------------------------------------------- #
Description: >
  Application Infrastructure - AppSync Stack

# --------------------------------------------------- #
Parameters:
  Environment:
    Default: dev
    Type: String
  CustomerId:
    Default: orb
    Type: String
  ProjectId:
    Default: integration-hub
    Type: String
  TracingIs:
    Default: Active
    Type: String
  SchemaS3Key:
    Type: String
    Description: Name of the GraphQL schema file in S3

# --------------------------------------------------- #
Resources:
  # IAM Roles for AppSync
  AppSyncServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: appsync.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess
        - arn:aws:iam::aws:policy/AWSLambda_FullAccess
      Policies:
        - PolicyName: SSMParameterAccess
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ssm:GetParameter
                  - ssm:GetParameters
                Resource: !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/${Environment}/${CustomerId}/${ProjectId}/*'
  

  AppSyncLoggingServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: appsync.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSAppSyncPushToCloudWatchLogs


  IntegrationHubApi:
    Type: AWS::AppSync::GraphQLApi
    Properties:
      Name: !Sub '${CustomerId}-${ProjectId}-${Environment}-appsync'
      AuthenticationType: AMAZON_COGNITO_USER_POOLS
      UserPoolConfig:
        UserPoolId: !Sub "resolve:ssm:${CustomerId}-${ProjectId}-${Environment}-cognito-user-pool-id"
        AwsRegion: !Ref AWS::Region
        DefaultAction: ALLOW
      AdditionalAuthenticationProviders:
        - AuthenticationType: API_KEY
      LogConfig:
        CloudWatchLogsRoleArn: !GetAtt AppSyncLoggingServiceRole.Arn
        FieldLogLevel: ALL
        ExcludeVerboseContent: false


  IntegrationHubApiKey:
    Type: AWS::AppSync::ApiKey
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      Description: "API Key for unauthenticated access"
      Expires: 1767211838


  ApiKeySecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub '${CustomerId}-${ProjectId}-${Environment}-appsync-graphql-key'
      Description: "AppSync API Key for unauthenticated access"
      SecretString: !GetAtt IntegrationHubApiKey.ApiKey


  IntegrationHubSchema:
    Type: AWS::AppSync::GraphQLSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      DefinitionS3Location: !Sub 's3://${CustomerId}-${ProjectId}-build-templates/${SchemaS3Key}'

  # Data Sources
  [[ schema.table ]]DataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      Name: [[ schema.table ]]DataSource
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt AppSyncServiceRole.Arn
      DynamoDBConfig:
        TableName: !Sub 'resolve:ssm:${CustomerId}-${ProjectId}-${Environment}-[[ schema.table | to_kebab_case ]]-table-name'
        AwsRegion: !Ref AWS::Region

  # [[ schema.table ]] Resolvers
  [[ schema.table ]]CreateResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Mutation
      FieldName: [[ schema.table ]]Create
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #set($input = {})
        #foreach($field in $ctx.args.input.keySet())
          #set($dynamoField = $util.str.toSnakeCase($field))
          $util.qr($input.put($dynamoField, $ctx.args.input.get($field)))
        #end

        {
          "version": "2017-02-28",
          "operation": "PutItem",
          "key": {
            "[[ schema.partition_key ]]": $util.dynamodb.toDynamoDBJson($input.[[ schema.partition_key ]])          },
          "attributeValues": $util.toJson($input)
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        {
          "StatusCode": 200,
          "Message": "[[ schema.table ]] created successfully",
          "Data": $ctx.args.input
        }


  [[ schema.table ]]QueryBy[[ schema.partition_key | to_pascal_case ]]Resolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Query
      FieldName: [[ schema.table ]]QueryBy[[ schema.partition_key | to_pascal_case ]]
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #if($ctx.args.input.[[ schema.partition_key | to_camel_case ]])
          {
            "version": "2017-02-28",
            "operation": "GetItem",
            "key": {
              "[[ schema.partition_key ]]": $util.dynamodb.toDynamoDBJson($ctx.args.input.[[ schema.partition_key | to_camel_case ]])
            }
          }
        #else
          $util.error("Invalid identifier. Must provide [[ schema.partition_key | to_camel_case ]]")
        #end
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        #set($response = {
          "StatusCode": 200,
          "Data": {}
        })
        
        #if($ctx.result)
          #set($result = {})
          #foreach($field in $ctx.result.keySet())
            #set($camelField = $util.str.toCamelCase($field))
            $util.qr($result.put($camelField, $ctx.result.get($field)))
          #end
          $util.qr($response.put("Data", $result))
        #else
          $util.qr($response.put("Data", null))
        #end
        
        $util.toJson($response)
  [[ schema.table ]]UpdateResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Mutation
      FieldName: [[ schema.table ]]Update
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #set($input = {})
        #foreach($field in $ctx.args.input.keySet())
          #set($dynamoField = $util.str.toSnakeCase($field))
          $util.qr($input.put($dynamoField, $ctx.args.input.get($field)))
        #end

        #if(!$input.[[ schema.partition_key ]])
          $util.error("[[ schema.partition_key | to_camel_case ]] is a required field for updates")
        #end
        
        #set($expNames = {})
        #set($expValues = {})
        #set($expSet = [])
        
        #set($updateCount = 0)
        #foreach($field in $input.keySet())
          #if($field != "[[ schema.partition_key ]]" )
            $util.qr($expNames.put("#$field", "$field"))
            $util.qr($expValues.put(":$field", $util.dynamodb.toDynamoDB($input.get($field))))
            $util.qr($expSet.add("#$field = :$field"))
            #set($updateCount = $updateCount + 1)
          #end
        #end
        
        #if($updateCount == 0)
          $util.error("No fields to update were provided")
        #end
        
        $util.qr($expNames.put("#updated_at", "updated_at"))
        $util.qr($expValues.put(":updated_at", $util.dynamodb.toDynamoDB($now)))
        $util.qr($expSet.add("#updated_at = :updated_at"))
        
        #set($expression = "SET " + $expSet.join(", "))
        
        {
          "version": "2018-05-29",
          "operation": "UpdateItem",
          "key": {
            "[[ schema.partition_key ]]": $util.dynamodb.toDynamoDBJson($input.[[ schema.partition_key ]])          },
          "update": {
            "expression": "$expression",
            "expressionNames": $util.toJson($expNames),
            "expressionValues": $util.toJson($expValues)
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        {
          "StatusCode": 200,
          "Message": "[[ schema.table ]] updated successfully",
          "Data": $ctx.args.input
        }
  [[ schema.table ]]DataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      Name: [[ schema.table ]]DataSource
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt AppSyncServiceRole.Arn
      DynamoDBConfig:
        TableName: !Sub 'resolve:ssm:${CustomerId}-${ProjectId}-${Environment}-[[ schema.table | to_kebab_case ]]-table-name'
        AwsRegion: !Ref AWS::Region

  # [[ schema.table ]] Resolvers
  [[ schema.table ]]CreateResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Mutation
      FieldName: [[ schema.table ]]Create
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #set($input = {})
        #foreach($field in $ctx.args.input.keySet())
          #set($dynamoField = $util.str.toSnakeCase($field))
          $util.qr($input.put($dynamoField, $ctx.args.input.get($field)))
        #end

        {
          "version": "2017-02-28",
          "operation": "PutItem",
          "key": {
            "[[ schema.partition_key ]]": $util.dynamodb.toDynamoDBJson($input.[[ schema.partition_key ]])            ,"[[ schema.sort_key ]]": $util.dynamodb.toDynamoDBJson($input.[[ schema.sort_key ]])          },
          "attributeValues": $util.toJson($input)
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        {
          "StatusCode": 200,
          "Message": "[[ schema.table ]] created successfully",
          "Data": $ctx.args.input
        }


  [[ schema.table ]]QueryBy[[ schema.partition_key | to_pascal_case ]]Resolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Query
      FieldName: [[ schema.table ]]QueryBy[[ schema.partition_key | to_pascal_case ]]
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #if($ctx.args.input.[[ schema.partition_key | to_camel_case ]])
          {
            "version": "2017-02-28",
            "operation": "GetItem",
            "key": {
              "[[ schema.partition_key ]]": $util.dynamodb.toDynamoDBJson($ctx.args.input.[[ schema.partition_key | to_camel_case ]])
            }
          }
        #else
          $util.error("Invalid identifier. Must provide [[ schema.partition_key | to_camel_case ]]")
        #end
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        #set($response = {
          "StatusCode": 200,
          "Data": {}
        })
        
        #if($ctx.result)
          #set($result = {})
          #foreach($field in $ctx.result.keySet())
            #set($camelField = $util.str.toCamelCase($field))
            $util.qr($result.put($camelField, $ctx.result.get($field)))
          #end
          $util.qr($response.put("Data", $result))
        #else
          $util.qr($response.put("Data", null))
        #end
        

        $util.toJson($response)  [[ schema.table ]]QueryBy[[ schema.sort_key | to_pascal_case ]]Resolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Query
      FieldName: [[ schema.table ]]QueryBy[[ schema.sort_key | to_pascal_case ]]
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #if($ctx.args.input.[[ schema.sort_key | to_camel_case ]])
          {
            "version": "2017-02-28",
            "operation": "Query",
            "index": "[[ schema.sort_key | to_snake_case ]]-index",
            "query": {
              "expression": "#[[ schema.sort_key | to_snake_case ]] = :[[ schema.sort_key | to_snake_case ]]",
              "expressionNames": {
                "#[[ schema.sort_key | to_snake_case ]]": "[[ schema.sort_key | to_snake_case ]]"
              },
              "expressionValues": {
                ":[[ schema.sort_key | to_snake_case ]]": $util.dynamodb.toDynamoDBJson($ctx.args.input.[[ schema.sort_key | to_camel_case ]])
              }
            }
          }
        #else
          $util.error("Invalid identifier. Must provide [[ schema.sort_key | to_camel_case ]]")
        #end
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        #set($response = {
          "StatusCode": 200,
          "Data": []
        })
        
        #if($ctx.result.items)
          #set($items = [])
          #foreach($item in $ctx.result.items)
            #set($result = {})
            #foreach($field in $item.keySet())
              #set($camelField = $util.str.toCamelCase($field))
              $util.qr($result.put($camelField, $item.get($field)))
            #end
            $util.qr($items.add($result))
          #end
          $util.qr($response.put("Data", $items))
        #end
        
        $util.toJson($response)


  [[ schema.table ]]QueryByBothResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Query
      FieldName: [[ schema.table ]]QueryByBoth
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #if($ctx.args.input.[[ schema.partition_key | to_camel_case ]] && $ctx.args.input.[[ schema.sort_key | to_camel_case ]])
          {
            "version": "2017-02-28",
            "operation": "GetItem",
            "key": {
              "[[ schema.partition_key ]]": $util.dynamodb.toDynamoDBJson($ctx.args.input.[[ schema.partition_key | to_camel_case ]])
              ,"[[ schema.sort_key ]]": $util.dynamodb.toDynamoDBJson($ctx.args.input.[[ schema.sort_key | to_camel_case ]])
            }
          }
        #else
          $util.error("Invalid identifiers. Must provide both [[ schema.partition_key | to_camel_case ]] and [[ schema.sort_key | to_camel_case ]]")
        #end
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        #set($response = {
          "StatusCode": 200,
          "Data": {}
        })
        
        #if($ctx.result)
          #set($result = {})
          #foreach($field in $ctx.result.keySet())
            #set($camelField = $util.str.toCamelCase($field))
            $util.qr($result.put($camelField, $ctx.result.get($field)))
          #end
          $util.qr($response.put("Data", $result))
        #else
          $util.qr($response.put("Data", null))
        #end
        
        $util.toJson($response)
  [[ schema.table ]]UpdateResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Mutation
      FieldName: [[ schema.table ]]Update
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #set($input = {})
        #foreach($field in $ctx.args.input.keySet())
          #set($dynamoField = $util.str.toSnakeCase($field))
          $util.qr($input.put($dynamoField, $ctx.args.input.get($field)))
        #end

        #if(!$input.[[ schema.partition_key ]])
          $util.error("[[ schema.partition_key | to_camel_case ]] is a required field for updates")
        #end
        
        #set($expNames = {})
        #set($expValues = {})
        #set($expSet = [])
        
        #set($updateCount = 0)
        #foreach($field in $input.keySet())
          #if($field != "[[ schema.partition_key ]]"  && $field != "[[ schema.sort_key ]]" )
            $util.qr($expNames.put("#$field", "$field"))
            $util.qr($expValues.put(":$field", $util.dynamodb.toDynamoDB($input.get($field))))
            $util.qr($expSet.add("#$field = :$field"))
            #set($updateCount = $updateCount + 1)
          #end
        #end
        
        #if($updateCount == 0)
          $util.error("No fields to update were provided")
        #end
        
        $util.qr($expNames.put("#updated_at", "updated_at"))
        $util.qr($expValues.put(":updated_at", $util.dynamodb.toDynamoDB($now)))
        $util.qr($expSet.add("#updated_at = :updated_at"))
        
        #set($expression = "SET " + $expSet.join(", "))
        
        {
          "version": "2018-05-29",
          "operation": "UpdateItem",
          "key": {
            "[[ schema.partition_key ]]": $util.dynamodb.toDynamoDBJson($input.[[ schema.partition_key ]])            ,"[[ schema.sort_key ]]": $util.dynamodb.toDynamoDBJson($input.[[ schema.sort_key ]])          },
          "update": {
            "expression": "$expression",
            "expressionNames": $util.toJson($expNames),
            "expressionValues": $util.toJson($expValues)
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        {
          "StatusCode": 200,
          "Message": "[[ schema.table ]] updated successfully",
          "Data": $ctx.args.input
        }
  [[ schema.table ]]DataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      Name: [[ schema.table ]]DataSource
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt AppSyncServiceRole.Arn
      DynamoDBConfig:
        TableName: !Sub 'resolve:ssm:${CustomerId}-${ProjectId}-${Environment}-[[ schema.table | to_kebab_case ]]-table-name'
        AwsRegion: !Ref AWS::Region

  # [[ schema.table ]] Resolvers
  [[ schema.table ]]CreateResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Mutation
      FieldName: [[ schema.table ]]Create
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #set($input = {})
        #foreach($field in $ctx.args.input.keySet())
          #set($dynamoField = $util.str.toSnakeCase($field))
          $util.qr($input.put($dynamoField, $ctx.args.input.get($field)))
        #end

        {
          "version": "2017-02-28",
          "operation": "PutItem",
          "key": {
            "[[ schema.partition_key ]]": $util.dynamodb.toDynamoDBJson($input.[[ schema.partition_key ]])            ,"[[ schema.sort_key ]]": $util.dynamodb.toDynamoDBJson($input.[[ schema.sort_key ]])          },
          "attributeValues": $util.toJson($input)
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        {
          "StatusCode": 200,
          "Message": "[[ schema.table ]] created successfully",
          "Data": $ctx.args.input
        }


  [[ schema.table ]]QueryBy[[ schema.partition_key | to_pascal_case ]]Resolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Query
      FieldName: [[ schema.table ]]QueryBy[[ schema.partition_key | to_pascal_case ]]
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #if($ctx.args.input.[[ schema.partition_key | to_camel_case ]])
          {
            "version": "2017-02-28",
            "operation": "GetItem",
            "key": {
              "[[ schema.partition_key ]]": $util.dynamodb.toDynamoDBJson($ctx.args.input.[[ schema.partition_key | to_camel_case ]])
            }
          }
        #else
          $util.error("Invalid identifier. Must provide [[ schema.partition_key | to_camel_case ]]")
        #end
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        #set($response = {
          "StatusCode": 200,
          "Data": {}
        })
        
        #if($ctx.result)
          #set($result = {})
          #foreach($field in $ctx.result.keySet())
            #set($camelField = $util.str.toCamelCase($field))
            $util.qr($result.put($camelField, $ctx.result.get($field)))
          #end
          $util.qr($response.put("Data", $result))
        #else
          $util.qr($response.put("Data", null))
        #end
        

        $util.toJson($response)  [[ schema.table ]]QueryBy[[ schema.sort_key | to_pascal_case ]]Resolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Query
      FieldName: [[ schema.table ]]QueryBy[[ schema.sort_key | to_pascal_case ]]
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #if($ctx.args.input.[[ schema.sort_key | to_camel_case ]])
          {
            "version": "2017-02-28",
            "operation": "Query",
            "index": "[[ schema.sort_key | to_snake_case ]]-index",
            "query": {
              "expression": "#[[ schema.sort_key | to_snake_case ]] = :[[ schema.sort_key | to_snake_case ]]",
              "expressionNames": {
                "#[[ schema.sort_key | to_snake_case ]]": "[[ schema.sort_key | to_snake_case ]]"
              },
              "expressionValues": {
                ":[[ schema.sort_key | to_snake_case ]]": $util.dynamodb.toDynamoDBJson($ctx.args.input.[[ schema.sort_key | to_camel_case ]])
              }
            }
          }
        #else
          $util.error("Invalid identifier. Must provide [[ schema.sort_key | to_camel_case ]]")
        #end
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        #set($response = {
          "StatusCode": 200,
          "Data": []
        })
        
        #if($ctx.result.items)
          #set($items = [])
          #foreach($item in $ctx.result.items)
            #set($result = {})
            #foreach($field in $item.keySet())
              #set($camelField = $util.str.toCamelCase($field))
              $util.qr($result.put($camelField, $item.get($field)))
            #end
            $util.qr($items.add($result))
          #end
          $util.qr($response.put("Data", $items))
        #end
        
        $util.toJson($response)


  [[ schema.table ]]QueryByBothResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Query
      FieldName: [[ schema.table ]]QueryByBoth
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #if($ctx.args.input.[[ schema.partition_key | to_camel_case ]] && $ctx.args.input.[[ schema.sort_key | to_camel_case ]])
          {
            "version": "2017-02-28",
            "operation": "GetItem",
            "key": {
              "[[ schema.partition_key ]]": $util.dynamodb.toDynamoDBJson($ctx.args.input.[[ schema.partition_key | to_camel_case ]])
              ,"[[ schema.sort_key ]]": $util.dynamodb.toDynamoDBJson($ctx.args.input.[[ schema.sort_key | to_camel_case ]])
            }
          }
        #else
          $util.error("Invalid identifiers. Must provide both [[ schema.partition_key | to_camel_case ]] and [[ schema.sort_key | to_camel_case ]]")
        #end
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        #set($response = {
          "StatusCode": 200,
          "Data": {}
        })
        
        #if($ctx.result)
          #set($result = {})
          #foreach($field in $ctx.result.keySet())
            #set($camelField = $util.str.toCamelCase($field))
            $util.qr($result.put($camelField, $ctx.result.get($field)))
          #end
          $util.qr($response.put("Data", $result))
        #else
          $util.qr($response.put("Data", null))
        #end
        
        $util.toJson($response)
  [[ schema.table ]]UpdateResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Mutation
      FieldName: [[ schema.table ]]Update
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #set($input = {})
        #foreach($field in $ctx.args.input.keySet())
          #set($dynamoField = $util.str.toSnakeCase($field))
          $util.qr($input.put($dynamoField, $ctx.args.input.get($field)))
        #end

        #if(!$input.[[ schema.partition_key ]])
          $util.error("[[ schema.partition_key | to_camel_case ]] is a required field for updates")
        #end
        
        #set($expNames = {})
        #set($expValues = {})
        #set($expSet = [])
        
        #set($updateCount = 0)
        #foreach($field in $input.keySet())
          #if($field != "[[ schema.partition_key ]]"  && $field != "[[ schema.sort_key ]]" )
            $util.qr($expNames.put("#$field", "$field"))
            $util.qr($expValues.put(":$field", $util.dynamodb.toDynamoDB($input.get($field))))
            $util.qr($expSet.add("#$field = :$field"))
            #set($updateCount = $updateCount + 1)
          #end
        #end
        
        #if($updateCount == 0)
          $util.error("No fields to update were provided")
        #end
        
        $util.qr($expNames.put("#updated_at", "updated_at"))
        $util.qr($expValues.put(":updated_at", $util.dynamodb.toDynamoDB($now)))
        $util.qr($expSet.add("#updated_at = :updated_at"))
        
        #set($expression = "SET " + $expSet.join(", "))
        
        {
          "version": "2018-05-29",
          "operation": "UpdateItem",
          "key": {
            "[[ schema.partition_key ]]": $util.dynamodb.toDynamoDBJson($input.[[ schema.partition_key ]])            ,"[[ schema.sort_key ]]": $util.dynamodb.toDynamoDBJson($input.[[ schema.sort_key ]])          },
          "update": {
            "expression": "$expression",
            "expressionNames": $util.toJson($expNames),
            "expressionValues": $util.toJson($expValues)
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        {
          "StatusCode": 200,
          "Message": "[[ schema.table ]] updated successfully",
          "Data": $ctx.args.input
        }
  [[ schema.table ]]DataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      Name: [[ schema.table ]]DataSource
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt AppSyncServiceRole.Arn
      DynamoDBConfig:
        TableName: !Sub 'resolve:ssm:${CustomerId}-${ProjectId}-${Environment}-[[ schema.table | to_kebab_case ]]-table-name'
        AwsRegion: !Ref AWS::Region

  # [[ schema.table ]] Resolvers
  [[ schema.table ]]CreateResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Mutation
      FieldName: [[ schema.table ]]Create
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #set($input = {})
        #foreach($field in $ctx.args.input.keySet())
          #set($dynamoField = $util.str.toSnakeCase($field))
          $util.qr($input.put($dynamoField, $ctx.args.input.get($field)))
        #end

        {
          "version": "2017-02-28",
          "operation": "PutItem",
          "key": {
            "[[ schema.partition_key ]]": $util.dynamodb.toDynamoDBJson($input.[[ schema.partition_key ]])            ,"[[ schema.sort_key ]]": $util.dynamodb.toDynamoDBJson($input.[[ schema.sort_key ]])          },
          "attributeValues": $util.toJson($input)
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        {
          "StatusCode": 200,
          "Message": "[[ schema.table ]] created successfully",
          "Data": $ctx.args.input
        }


  [[ schema.table ]]QueryBy[[ schema.partition_key | to_pascal_case ]]Resolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Query
      FieldName: [[ schema.table ]]QueryBy[[ schema.partition_key | to_pascal_case ]]
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #if($ctx.args.input.[[ schema.partition_key | to_camel_case ]])
          {
            "version": "2017-02-28",
            "operation": "GetItem",
            "key": {
              "[[ schema.partition_key ]]": $util.dynamodb.toDynamoDBJson($ctx.args.input.[[ schema.partition_key | to_camel_case ]])
            }
          }
        #else
          $util.error("Invalid identifier. Must provide [[ schema.partition_key | to_camel_case ]]")
        #end
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        #set($response = {
          "StatusCode": 200,
          "Data": {}
        })
        
        #if($ctx.result)
          #set($result = {})
          #foreach($field in $ctx.result.keySet())
            #set($camelField = $util.str.toCamelCase($field))
            $util.qr($result.put($camelField, $ctx.result.get($field)))
          #end
          $util.qr($response.put("Data", $result))
        #else
          $util.qr($response.put("Data", null))
        #end
        

        $util.toJson($response)  [[ schema.table ]]QueryBy[[ schema.sort_key | to_pascal_case ]]Resolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Query
      FieldName: [[ schema.table ]]QueryBy[[ schema.sort_key | to_pascal_case ]]
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #if($ctx.args.input.[[ schema.sort_key | to_camel_case ]])
          {
            "version": "2017-02-28",
            "operation": "Query",
            "index": "[[ schema.sort_key | to_snake_case ]]-index",
            "query": {
              "expression": "#[[ schema.sort_key | to_snake_case ]] = :[[ schema.sort_key | to_snake_case ]]",
              "expressionNames": {
                "#[[ schema.sort_key | to_snake_case ]]": "[[ schema.sort_key | to_snake_case ]]"
              },
              "expressionValues": {
                ":[[ schema.sort_key | to_snake_case ]]": $util.dynamodb.toDynamoDBJson($ctx.args.input.[[ schema.sort_key | to_camel_case ]])
              }
            }
          }
        #else
          $util.error("Invalid identifier. Must provide [[ schema.sort_key | to_camel_case ]]")
        #end
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        #set($response = {
          "StatusCode": 200,
          "Data": []
        })
        
        #if($ctx.result.items)
          #set($items = [])
          #foreach($item in $ctx.result.items)
            #set($result = {})
            #foreach($field in $item.keySet())
              #set($camelField = $util.str.toCamelCase($field))
              $util.qr($result.put($camelField, $item.get($field)))
            #end
            $util.qr($items.add($result))
          #end
          $util.qr($response.put("Data", $items))
        #end
        
        $util.toJson($response)


  [[ schema.table ]]QueryByBothResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Query
      FieldName: [[ schema.table ]]QueryByBoth
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #if($ctx.args.input.[[ schema.partition_key | to_camel_case ]] && $ctx.args.input.[[ schema.sort_key | to_camel_case ]])
          {
            "version": "2017-02-28",
            "operation": "GetItem",
            "key": {
              "[[ schema.partition_key ]]": $util.dynamodb.toDynamoDBJson($ctx.args.input.[[ schema.partition_key | to_camel_case ]])
              ,"[[ schema.sort_key ]]": $util.dynamodb.toDynamoDBJson($ctx.args.input.[[ schema.sort_key | to_camel_case ]])
            }
          }
        #else
          $util.error("Invalid identifiers. Must provide both [[ schema.partition_key | to_camel_case ]] and [[ schema.sort_key | to_camel_case ]]")
        #end
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        #set($response = {
          "StatusCode": 200,
          "Data": {}
        })
        
        #if($ctx.result)
          #set($result = {})
          #foreach($field in $ctx.result.keySet())
            #set($camelField = $util.str.toCamelCase($field))
            $util.qr($result.put($camelField, $ctx.result.get($field)))
          #end
          $util.qr($response.put("Data", $result))
        #else
          $util.qr($response.put("Data", null))
        #end
        
        $util.toJson($response)
  [[ schema.table ]]UpdateResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Mutation
      FieldName: [[ schema.table ]]Update
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #set($input = {})
        #foreach($field in $ctx.args.input.keySet())
          #set($dynamoField = $util.str.toSnakeCase($field))
          $util.qr($input.put($dynamoField, $ctx.args.input.get($field)))
        #end

        #if(!$input.[[ schema.partition_key ]])
          $util.error("[[ schema.partition_key | to_camel_case ]] is a required field for updates")
        #end
        
        #set($expNames = {})
        #set($expValues = {})
        #set($expSet = [])
        
        #set($updateCount = 0)
        #foreach($field in $input.keySet())
          #if($field != "[[ schema.partition_key ]]"  && $field != "[[ schema.sort_key ]]" )
            $util.qr($expNames.put("#$field", "$field"))
            $util.qr($expValues.put(":$field", $util.dynamodb.toDynamoDB($input.get($field))))
            $util.qr($expSet.add("#$field = :$field"))
            #set($updateCount = $updateCount + 1)
          #end
        #end
        
        #if($updateCount == 0)
          $util.error("No fields to update were provided")
        #end
        
        $util.qr($expNames.put("#updated_at", "updated_at"))
        $util.qr($expValues.put(":updated_at", $util.dynamodb.toDynamoDB($now)))
        $util.qr($expSet.add("#updated_at = :updated_at"))
        
        #set($expression = "SET " + $expSet.join(", "))
        
        {
          "version": "2018-05-29",
          "operation": "UpdateItem",
          "key": {
            "[[ schema.partition_key ]]": $util.dynamodb.toDynamoDBJson($input.[[ schema.partition_key ]])            ,"[[ schema.sort_key ]]": $util.dynamodb.toDynamoDBJson($input.[[ schema.sort_key ]])          },
          "update": {
            "expression": "$expression",
            "expressionNames": $util.toJson($expNames),
            "expressionValues": $util.toJson($expValues)
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        {
          "StatusCode": 200,
          "Message": "[[ schema.table ]] updated successfully",
          "Data": $ctx.args.input
        }
  [[ schema.table ]]DataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      Name: [[ schema.table ]]DataSource
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt AppSyncServiceRole.Arn
      DynamoDBConfig:
        TableName: !Sub 'resolve:ssm:${CustomerId}-${ProjectId}-${Environment}-[[ schema.table | to_kebab_case ]]-table-name'
        AwsRegion: !Ref AWS::Region

  # [[ schema.table ]] Resolvers
  [[ schema.table ]]CreateResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Mutation
      FieldName: [[ schema.table ]]Create
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #set($input = {})
        #foreach($field in $ctx.args.input.keySet())
          #set($dynamoField = $util.str.toSnakeCase($field))
          $util.qr($input.put($dynamoField, $ctx.args.input.get($field)))
        #end

        {
          "version": "2017-02-28",
          "operation": "PutItem",
          "key": {
            "[[ schema.partition_key ]]": $util.dynamodb.toDynamoDBJson($input.[[ schema.partition_key ]])          },
          "attributeValues": $util.toJson($input)
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        {
          "StatusCode": 200,
          "Message": "[[ schema.table ]] created successfully",
          "Data": $ctx.args.input
        }


  [[ schema.table ]]QueryBy[[ schema.partition_key | to_pascal_case ]]Resolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Query
      FieldName: [[ schema.table ]]QueryBy[[ schema.partition_key | to_pascal_case ]]
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #if($ctx.args.input.[[ schema.partition_key | to_camel_case ]])
          {
            "version": "2017-02-28",
            "operation": "GetItem",
            "key": {
              "[[ schema.partition_key ]]": $util.dynamodb.toDynamoDBJson($ctx.args.input.[[ schema.partition_key | to_camel_case ]])
            }
          }
        #else
          $util.error("Invalid identifier. Must provide [[ schema.partition_key | to_camel_case ]]")
        #end
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        #set($response = {
          "StatusCode": 200,
          "Data": {}
        })
        
        #if($ctx.result)
          #set($result = {})
          #foreach($field in $ctx.result.keySet())
            #set($camelField = $util.str.toCamelCase($field))
            $util.qr($result.put($camelField, $ctx.result.get($field)))
          #end
          $util.qr($response.put("Data", $result))
        #else
          $util.qr($response.put("Data", null))
        #end
        
        $util.toJson($response)
  [[ schema.table ]]UpdateResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: IntegrationHubSchema
    Properties:
      ApiId: !GetAtt IntegrationHubApi.ApiId
      TypeName: Mutation
      FieldName: [[ schema.table ]]Update
      DataSourceName: !GetAtt [[ schema.table ]]DataSource.Name
      RequestMappingTemplate: |
        #set($input = {})
        #foreach($field in $ctx.args.input.keySet())
          #set($dynamoField = $util.str.toSnakeCase($field))
          $util.qr($input.put($dynamoField, $ctx.args.input.get($field)))
        #end

        #if(!$input.[[ schema.partition_key ]])
          $util.error("[[ schema.partition_key | to_camel_case ]] is a required field for updates")
        #end
        
        #set($expNames = {})
        #set($expValues = {})
        #set($expSet = [])
        
        #set($updateCount = 0)
        #foreach($field in $input.keySet())
          #if($field != "[[ schema.partition_key ]]" )
            $util.qr($expNames.put("#$field", "$field"))
            $util.qr($expValues.put(":$field", $util.dynamodb.toDynamoDB($input.get($field))))
            $util.qr($expSet.add("#$field = :$field"))
            #set($updateCount = $updateCount + 1)
          #end
        #end
        
        #if($updateCount == 0)
          $util.error("No fields to update were provided")
        #end
        
        $util.qr($expNames.put("#updated_at", "updated_at"))
        $util.qr($expValues.put(":updated_at", $util.dynamodb.toDynamoDB($now)))
        $util.qr($expSet.add("#updated_at = :updated_at"))
        
        #set($expression = "SET " + $expSet.join(", "))
        
        {
          "version": "2018-05-29",
          "operation": "UpdateItem",
          "key": {
            "[[ schema.partition_key ]]": $util.dynamodb.toDynamoDBJson($input.[[ schema.partition_key ]])          },
          "update": {
            "expression": "$expression",
            "expressionNames": $util.toJson($expNames),
            "expressionValues": $util.toJson($expValues)
          }
        }
      ResponseMappingTemplate: |
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #end
        
        {
          "StatusCode": 200,
          "Message": "[[ schema.table ]] updated successfully",
          "Data": $ctx.args.input
        }
# --------------------------------------------------- #
Outputs:
  GraphQLApiUrl:
    Description: 'URL of the AppSync GraphQL API'
    Value: !GetAtt IntegrationHubApi.GraphQLUrl
  GraphQLApiKeySecretName:
    Description: 'Name of the Secret containing the AppSync API Key'
    Value: !Ref ApiKeySecret 