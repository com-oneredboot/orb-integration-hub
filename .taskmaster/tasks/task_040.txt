# Task ID: 40
# Title: Implement Backend Infrastructure for Organization Invitation System
# Status: pending
# Dependencies: 1, 3, 5, 30
# Priority: medium
# Description: Develop comprehensive backend infrastructure supporting the organization invitation system with GraphQL schema, DynamoDB tables, Lambda resolvers, real-time subscriptions, and security controls for managing invitation lifecycle and audit trails.
# Details:
Implement comprehensive backend infrastructure across multiple critical components: **1) GraphQL Schema Design:** Create invitation entities schema using lambda-secured entity patterns with types for Invitation (invitationId as primary index following PascalCase conventions, organizationId, inviterUserId, inviteeUserId, role, status, expiresAt, createdAt, updatedAt), InvitationStatus enum (PENDING, ACCEPTED, DECLINED, EXPIRED), and InvitationAuditEntry for audit trail. Define queries using auto-generated patterns (getInvitation, listInvitations) with custom indexes getInvitationsByEmail and getInvitationsByOrganizationId following existing lambda-secured entity patterns and PascalCase naming conventions. Implement mutations using generate.py and .jinja files for lambda-secured type with auto-generated CreateInvitation and UpdateInvitation mutations (resend/accept/decline/revoke operations will use UpdateInvitation). Update .jinja templates to support subscriptions with onInvitationStatusChange filtered by userId. **2) DynamoDB Table Design:** Define invitations.yml configuration file with proper entity definition including invitationId as primary key (using PascalCase), GSI specifications for organizationId and inviteeUserId lookups, and TTL attribute for automatic expiration cleanup. The DynamoDB table CloudFormation template will be automatically generated when generate.py is executed with the invitations.yml configuration. Create separate 'InvitationAuditTrail' table configuration with composite key (invitationId as PK, timestamp as SK) for immutable audit logging. **3) Lambda Resolvers Implementation:** Follow organizations resolver patterns with 3-layer security architecture, decorator patterns, and organization-scoped access controls. Create InvitationsPermissions enum or extend OrganizationPermissions to be more generic if permissions can be shared across entities. Implement permission-based access control: Only CUSTOMERS who are OWNERS (userId = organizationId) can CREATE Organization Invitations and DELETE (revoke) invitations; Application Invitations come from CUSTOMERS who are Organization Administrators; USERS and up can read notifications and UPDATE (accept/reject) invitations. Build createInvitation resolver with userId validation, existing user checks, role validation, duplicate invitation prevention, and proper permission decorators. Implement acceptInvitation, declineInvitation, resendInvitation, and revokeInvitation resolvers using UpdateInvitation pattern with 3-layer security validation and organization-scoped authorization checks. Add invitation audit events to existing AuditEventType enum (INVITATION_CREATED, INVITATION_ACCEPTED, INVITATION_DECLINED, INVITATION_REVOKED, INVITATION_EXPIRED). Create background Lambda for expiration handling with CloudWatch Events trigger and audit logging. **4) AppSync Real-time Subscriptions:** Update .jinja templates to support subscription generation for lambda-secured entities. Configure AppSync subscriptions for invitation events (status changes, create, update, delete) with proper filtering by userId to ensure users only receive updates for invitations relevant to them. Implement individual subscription messages for each change (not batched) with subscription permissions allowing everyone read/CREATE access since users need to receive invitations and accept/reject them. Set up connection management for real-time notifications optimized for low traffic volume with few organizations and few invitations. **5) IAM Policies and Security:** Follow the same IAM policy structure as organizations resolver to maintain consistency and DRY principles. Reuse existing patterns from organizations implementation for invitation management permissions. Use single Lambda execution role unless specific security requirements dictate separation. Identify any specific security requirements for invitation data beyond standard organization-scoped access controls. Implement rate limiting following organizations pattern - evaluate whether to create new invitationRateLimit table or rename/reuse existing ownershipTransferRequests table for invitation rate limiting. All Lambda functions will be accessed through AppSync server (no direct service-to-service authentication needed). **6) Internal Notification System Development:** Build comprehensive internal notification system from scratch to support organization invitation workflows. Create notification infrastructure with DynamoDB table for notification storage including notificationId (primary key), userId, type, title, message, status (SENT, DELIVERED, READ), metadata (invitation details), createdAt, readAt, and TTL for post-read expiration. Implement notification templates for organization invitations: invitation created (notify invitee), invitation accepted (notify inviter), invitation declined (notify inviter), invitation expired (notify both inviter and invitee), and invitation revoked (notify invitee). Design professional yet concise templates without specific branding requirements. Build notification delivery system with in-app notifications and generic email notifications ("you have a new notification" type). Implement notification status tracking (sent, delivered, read) with delivery confirmation mechanisms. Create Lambda functions for notification processing, email delivery, and TTL-based cleanup of read notifications. Integrate notification triggers into invitation lifecycle events ensuring both inviter and invitee receive appropriate notifications based on event type. Set up notification preferences and delivery tracking with audit logging. **7) Validation and Business Logic:** Implement comprehensive validation and business logic with the following requirements: User existence validation must be performed via users service API calls (not direct DynamoDB access). Implement duplicate invitation prevention by user/organization combination - if an invitation already exists for the same user and organization, treat role differences as updates to the existing invitation rather than creating duplicates. No invitation limits per organization are required. Organization validation must ensure the organization is active status, the current user must be the userId associated with organizationId (OWNER verification), and the user must have CUSTOMER status (paying customer). Implement message length validation with 1000 character limit for invitation messages. Maintain audit trail persistence for all invitation events, with the ability to remove expired records for cleanup purposes. Create expiration logic with 7-day default and 1-14 day configurable range. Build role validation against organization role definitions.

# Test Strategy:
Execute comprehensive backend validation through multiple testing approaches: **1) GraphQL Schema Testing:** Unit tests for all auto-generated and custom GraphQL resolvers covering success paths, error conditions, and edge cases. Test schema validation with malformed inputs and boundary conditions using PascalCase attribute naming. Validate subscription functionality with updated .jinja templates and real-time message delivery filtered by userId. **2) DynamoDB Integration Testing:** Test auto-generated table operations with invitationId primary key (PascalCase) and various data scenarios including concurrent writes, TTL expiration, and GSI queries for organizationId and inviteeUserId. Validate that generate.py properly creates the CloudFormation template from invitations.yml configuration. Validate audit trail persistence with proper ordering and immutability. Test performance with large datasets and query optimization. **3) Lambda Function Testing:** Unit tests for all resolver functions including auto-generated CreateInvitation and UpdateInvitation mutations with mocked dependencies and comprehensive error handling validation. Test 3-layer security architecture, decorator patterns, and permission-based access control scenarios. Integration tests with actual DynamoDB and AppSync services. Test expiration handling Lambda with CloudWatch Events simulation and audit logging. **4) Security and Authorization Testing:** Penetration testing for IAM policy enforcement following organizations resolver patterns and resource access controls. Test permission-based access: OWNERS can CREATE/DELETE invitations, Organization Administrators can send Application Invitations, USERS can READ/UPDATE invitations. Validate cross-organization access prevention and privilege escalation scenarios. Test JWT token handling and user context propagation with userId-based filtering. Validate single Lambda execution role security model and AppSync server access patterns. **5) Rate Limiting Testing:** Test rate limiting implementation following organizations pattern. Validate whether new invitationRateLimit table or reused ownershipTransferRequests table properly prevents invitation spam and abuse scenarios. **6) Real-time Subscription Testing:** Test AppSync subscription delivery with updated .jinja templates and multiple concurrent connections. Validate subscription filtering by userId ensuring users only receive relevant invitation updates. Test individual subscription message delivery for each event type (status changes, create, update, delete) with proper authorization allowing everyone read/CREATE permissions. Test connection handling under low traffic volume scenarios optimized for few organizations and few invitations. Validate subscription reconnection scenarios and message ordering. **7) Notification System Testing:** Comprehensive testing of internal notification system including notification creation, delivery tracking, and status updates. Test notification templates for all invitation events (created, accepted, declined, expired, revoked) with proper recipient targeting (inviter vs invitee). Validate in-app notification delivery and generic email notification functionality. Test notification status progression (sent, delivered, read) with delivery confirmation mechanisms. Validate TTL-based cleanup of read notifications and proper expiration handling. Test notification preferences and audit logging. Load testing for notification processing under concurrent invitation operations. **8) Validation and Business Logic Testing:** Test user existence validation via users service API calls with various scenarios including valid users, non-existent users, and service unavailability. Validate duplicate invitation prevention by user/organization combination, ensuring role differences trigger updates rather than creating duplicates. Test organization validation including active status verification, OWNER verification (userId = organizationId), and CUSTOMER status validation. Validate message length limits with 1000 character boundary testing including edge cases at exactly 1000 characters. Test audit trail persistence and expired record cleanup functionality. Validate expiration logic with 7-day default and 1-14 day configurable range boundary testing. **9) End-to-End Workflow Testing:** Complete invitation lifecycle testing from creation through acceptance/decline using auto-generated mutations with real user scenarios and PascalCase attribute handling. Test notification delivery integration across all invitation events with proper recipient targeting. Validate audit trail completeness across all operations with proper AuditEventType logging. Test notification system integration with invitation expiration events. **10) Performance and Load Testing:** Load testing for concurrent invitation operations and subscription connections optimized for low traffic volume. Test DynamoDB performance under high throughput scenarios with invitationId indexing. Validate Lambda cold start performance and optimization for auto-generated resolvers with security decorators. Test notification system performance under high notification volume with proper delivery tracking and TTL cleanup. Test users service API call performance and error handling under various load conditions.
