# AUTO-GENERATED by orb-schema-generator v0.18.3 - DO NOT EDIT
# Regenerate with: orb-schema generate
"""
Generated Python models for SmsRateLimit
"""

from pydantic import BaseModel, ConfigDict, Field, field_validator
from typing import List, Optional
from datetime import datetime


# CRUD Input Types
class SmsRateLimitCreateInput(BaseModel):
    """SmsRateLimit create input."""

    phone_number: str = Field(
        ..., description="Phone number used as the rate limit key (primary key)"
    )
    request_count: float = Field(
        ..., description="Number of SMS requests made within the rate limit window"
    )
    first_request_time: datetime = Field(
        ..., description="Timestamp of the first request in the current rate limit window"
    )
    ttl: float = Field(..., description="Time-to-live timestamp for automatic record cleanup")


class SmsRateLimitUpdateInput(BaseModel):
    """SmsRateLimit update input."""

    phone_number: Optional[str] = Field(
        ..., description="Phone number used as the rate limit key (primary key)"
    )
    request_count: Optional[float] = Field(
        ..., description="Number of SMS requests made within the rate limit window"
    )
    first_request_time: Optional[datetime] = Field(
        ..., description="Timestamp of the first request in the current rate limit window"
    )
    ttl: Optional[float] = Field(
        ..., description="Time-to-live timestamp for automatic record cleanup"
    )


class SmsRateLimitDeleteInput(BaseModel):
    """SmsRateLimit delete input."""

    phone_number: str


class SmsRateLimitDisableInput(BaseModel):
    """SmsRateLimit disable input."""

    phone_number: str
    disabled: bool


# Query Input Types
class SmsRateLimitQueryByPhoneNumberInput(BaseModel):
    """SmsRateLimit query by phoneNumber."""

    phone_number: str


# Main Model
class SmsRateLimit(BaseModel):
    """SmsRateLimit model."""

    model_config = ConfigDict(from_attributes=True)

    phone_number: str = Field(
        ..., description="Phone number used as the rate limit key (primary key)"
    )
    request_count: float = Field(
        ..., description="Number of SMS requests made within the rate limit window"
    )
    first_request_time: datetime = Field(
        ..., description="Timestamp of the first request in the current rate limit window"
    )
    ttl: float = Field(..., description="Time-to-live timestamp for automatic record cleanup")

    @field_validator("first_request_time", mode="before")
    @classmethod
    def parse_first_request_time(cls, value):
        """Parse timestamp to epoch seconds."""
        if value is None:
            return None
        if isinstance(value, int):
            return value
        if isinstance(value, float):
            return int(value)
        if isinstance(value, datetime):
            return int(value.timestamp())
        if isinstance(value, str):
            try:
                dt = datetime.fromisoformat(value.replace("Z", "+00:00"))
                return int(dt.timestamp())
            except (ValueError, TypeError):
                pass
        return value


# Response Types
class SmsRateLimitResponse(BaseModel):
    """SmsRateLimit response."""

    StatusCode: int
    Message: Optional[str] = None
    Data: Optional[SmsRateLimit] = None


class SmsRateLimitListResponse(BaseModel):
    """SmsRateLimit list response."""

    StatusCode: int
    Message: Optional[str] = None
    Data: Optional[List[SmsRateLimit]] = None


# CRUD Response Aliases
SmsRateLimitCreateResponse = SmsRateLimitResponse
SmsRateLimitUpdateResponse = SmsRateLimitResponse
SmsRateLimitDeleteResponse = SmsRateLimitResponse
SmsRateLimitDisableResponse = SmsRateLimitResponse
