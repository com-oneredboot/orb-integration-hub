# AUTO-GENERATED by orb-schema-generator v1.3.0 - DO NOT EDIT
# Regenerate with: orb-schema generate
"""
Generated Python models for ApplicationApiKeys
"""

from pydantic import BaseModel, ConfigDict, Field, field_validator
from typing import List, Optional
from datetime import datetime

from ..enums.application_api_key_status_enum import ApplicationApiKeyStatus
from ..enums.application_api_key_type_enum import ApplicationApiKeyType
from ..enums.environment_enum import Environment


# CRUD Input Types
class ApplicationApiKeysCreateInput(BaseModel):
    """ApplicationApiKeys create input."""

    application_api_key_id: str = Field(..., description="Unique identifier for the API key record (primary key)")
    application_id: str = Field(..., description="ID of the application this key belongs to (foreign key to Applications)")
    organization_id: str = Field(..., description="ID of the organization (denormalized for context)")
    environment: Environment = Field(..., description="Environment this key is valid for")
    key_hash: str = Field(..., description="SHA-256 hash of the API key (for secure lookup)")
    key_prefix: str = Field(..., description="First 12 chars of key for display (e.g., pk_dev_xxxx or sk_dev_xxxx)")
    key_type: ApplicationApiKeyType = Field(..., description="Type of API key (PUBLISHABLE for frontend, SECRET for backend)")
    permissions: Optional[List[str]] = Field(None, description="List of permission strings for this key (e.g., read:users, write:groups)")
    status: ApplicationApiKeyStatus = Field(..., description="Current status of the API key")
    next_key_hash: Optional[str] = Field(None, description="Hash of the next key during rotation (both keys valid)")
    activates_at: Optional[datetime] = Field(None, description="Future activation timestamp (null = immediate activation)")
    expires_at: Optional[datetime] = Field(None, description="Expiration timestamp for ROTATING keys (7 days after regeneration) or REVOKED keys (set to revokedAt)")
    revoked_at: Optional[datetime] = Field(None, description="When the key was revoked (null if not revoked)")
    last_used_at: Optional[datetime] = Field(None, description="Timestamp of last key usage")
    created_at: datetime = Field(..., description="When the key was created")
    updated_at: datetime = Field(..., description="When the key was last updated")
    ttl: Optional[float] = Field(None, description="DynamoDB TTL attribute (Unix timestamp for auto-deletion 30 days after expiresAt)")


class ApplicationApiKeysUpdateInput(BaseModel):
    """ApplicationApiKeys update input."""

    application_api_key_id: Optional[str] = Field(..., description="Unique identifier for the API key record (primary key)")
    application_id: Optional[str] = Field(..., description="ID of the application this key belongs to (foreign key to Applications)")
    organization_id: Optional[str] = Field(..., description="ID of the organization (denormalized for context)")
    environment: Optional[Environment] = Field(..., description="Environment this key is valid for")
    key_hash: Optional[str] = Field(..., description="SHA-256 hash of the API key (for secure lookup)")
    key_prefix: Optional[str] = Field(..., description="First 12 chars of key for display (e.g., pk_dev_xxxx or sk_dev_xxxx)")
    key_type: Optional[ApplicationApiKeyType] = Field(..., description="Type of API key (PUBLISHABLE for frontend, SECRET for backend)")
    permissions: Optional[List[str]] = Field(None, description="List of permission strings for this key (e.g., read:users, write:groups)")
    status: Optional[ApplicationApiKeyStatus] = Field(..., description="Current status of the API key")
    next_key_hash: Optional[str] = Field(None, description="Hash of the next key during rotation (both keys valid)")
    activates_at: Optional[datetime] = Field(None, description="Future activation timestamp (null = immediate activation)")
    expires_at: Optional[datetime] = Field(None, description="Expiration timestamp for ROTATING keys (7 days after regeneration) or REVOKED keys (set to revokedAt)")
    revoked_at: Optional[datetime] = Field(None, description="When the key was revoked (null if not revoked)")
    last_used_at: Optional[datetime] = Field(None, description="Timestamp of last key usage")
    created_at: Optional[datetime] = Field(..., description="When the key was created")
    updated_at: Optional[datetime] = Field(..., description="When the key was last updated")
    ttl: Optional[float] = Field(None, description="DynamoDB TTL attribute (Unix timestamp for auto-deletion 30 days after expiresAt)")


class ApplicationApiKeysDeleteInput(BaseModel):
    """ApplicationApiKeys delete input."""

    application_api_key_id: str


class ApplicationApiKeysDisableInput(BaseModel):
    """ApplicationApiKeys disable input."""

    application_api_key_id: str
    disabled: bool



# Query Input Types
class ApplicationApiKeysQueryByApplicationApiKeyIdInput(BaseModel):
    """ApplicationApiKeys query by applicationApiKeyId."""

    application_api_key_id: str


class ApplicationApiKeysQueryByApplicationIdInput(BaseModel):
    """ApplicationApiKeys query by applicationId."""

    application_id: str


class ApplicationApiKeysQueryByKeyHashInput(BaseModel):
    """ApplicationApiKeys query by keyHash."""

    key_hash: str


# Main Model
class ApplicationApiKeys(BaseModel):
    """ApplicationApiKeys model."""

    model_config = ConfigDict(from_attributes=True)

    application_api_key_id: str = Field(..., description="Unique identifier for the API key record (primary key)")
    application_id: str = Field(..., description="ID of the application this key belongs to (foreign key to Applications)")
    organization_id: str = Field(..., description="ID of the organization (denormalized for context)")
    environment: Environment = Field(..., description="Environment this key is valid for")
    key_hash: str = Field(..., description="SHA-256 hash of the API key (for secure lookup)")
    key_prefix: str = Field(..., description="First 12 chars of key for display (e.g., pk_dev_xxxx or sk_dev_xxxx)")
    key_type: ApplicationApiKeyType = Field(..., description="Type of API key (PUBLISHABLE for frontend, SECRET for backend)")
    permissions: Optional[List[str]] = Field(None, description="List of permission strings for this key (e.g., read:users, write:groups)")
    status: ApplicationApiKeyStatus = Field(..., description="Current status of the API key")
    next_key_hash: Optional[str] = Field(None, description="Hash of the next key during rotation (both keys valid)")
    activates_at: Optional[datetime] = Field(None, description="Future activation timestamp (null = immediate activation)")
    expires_at: Optional[datetime] = Field(None, description="Expiration timestamp for ROTATING keys (7 days after regeneration) or REVOKED keys (set to revokedAt)")
    revoked_at: Optional[datetime] = Field(None, description="When the key was revoked (null if not revoked)")
    last_used_at: Optional[datetime] = Field(None, description="Timestamp of last key usage")
    created_at: datetime = Field(..., description="When the key was created")
    updated_at: datetime = Field(..., description="When the key was last updated")
    ttl: Optional[float] = Field(None, description="DynamoDB TTL attribute (Unix timestamp for auto-deletion 30 days after expiresAt)")

    @field_validator("activates_at", mode="before")
    @classmethod
    def parse_activates_at(cls, value):
        """Parse timestamp to epoch seconds."""
        if value is None:
            return None
        if isinstance(value, int):
            return value
        if isinstance(value, float):
            return int(value)
        if isinstance(value, datetime):
            return int(value.timestamp())
        if isinstance(value, str):
            try:
                dt = datetime.fromisoformat(value.replace("Z", "+00:00"))
                return int(dt.timestamp())
            except (ValueError, TypeError):
                pass
        return value

    @field_validator("expires_at", mode="before")
    @classmethod
    def parse_expires_at(cls, value):
        """Parse timestamp to epoch seconds."""
        if value is None:
            return None
        if isinstance(value, int):
            return value
        if isinstance(value, float):
            return int(value)
        if isinstance(value, datetime):
            return int(value.timestamp())
        if isinstance(value, str):
            try:
                dt = datetime.fromisoformat(value.replace("Z", "+00:00"))
                return int(dt.timestamp())
            except (ValueError, TypeError):
                pass
        return value

    @field_validator("revoked_at", mode="before")
    @classmethod
    def parse_revoked_at(cls, value):
        """Parse timestamp to epoch seconds."""
        if value is None:
            return None
        if isinstance(value, int):
            return value
        if isinstance(value, float):
            return int(value)
        if isinstance(value, datetime):
            return int(value.timestamp())
        if isinstance(value, str):
            try:
                dt = datetime.fromisoformat(value.replace("Z", "+00:00"))
                return int(dt.timestamp())
            except (ValueError, TypeError):
                pass
        return value

    @field_validator("last_used_at", mode="before")
    @classmethod
    def parse_last_used_at(cls, value):
        """Parse timestamp to epoch seconds."""
        if value is None:
            return None
        if isinstance(value, int):
            return value
        if isinstance(value, float):
            return int(value)
        if isinstance(value, datetime):
            return int(value.timestamp())
        if isinstance(value, str):
            try:
                dt = datetime.fromisoformat(value.replace("Z", "+00:00"))
                return int(dt.timestamp())
            except (ValueError, TypeError):
                pass
        return value

    @field_validator("created_at", mode="before")
    @classmethod
    def parse_created_at(cls, value):
        """Parse timestamp to epoch seconds."""
        if value is None:
            return None
        if isinstance(value, int):
            return value
        if isinstance(value, float):
            return int(value)
        if isinstance(value, datetime):
            return int(value.timestamp())
        if isinstance(value, str):
            try:
                dt = datetime.fromisoformat(value.replace("Z", "+00:00"))
                return int(dt.timestamp())
            except (ValueError, TypeError):
                pass
        return value

    @field_validator("updated_at", mode="before")
    @classmethod
    def parse_updated_at(cls, value):
        """Parse timestamp to epoch seconds."""
        if value is None:
            return None
        if isinstance(value, int):
            return value
        if isinstance(value, float):
            return int(value)
        if isinstance(value, datetime):
            return int(value.timestamp())
        if isinstance(value, str):
            try:
                dt = datetime.fromisoformat(value.replace("Z", "+00:00"))
                return int(dt.timestamp())
            except (ValueError, TypeError):
                pass
        return value


# Response Types
class ApplicationApiKeysCreateResponse(BaseModel):
    """ApplicationApiKeys create response."""

    code: int
    success: bool
    message: Optional[str] = None
    item: Optional[ApplicationApiKeys] = None


class ApplicationApiKeysUpdateResponse(BaseModel):
    """ApplicationApiKeys update response."""

    code: int
    success: bool
    message: Optional[str] = None
    item: Optional[ApplicationApiKeys] = None


class ApplicationApiKeysDeleteResponse(BaseModel):
    """ApplicationApiKeys delete response."""

    code: int
    success: bool
    message: Optional[str] = None
    item: Optional[ApplicationApiKeys] = None


class ApplicationApiKeysDisableResponse(BaseModel):
    """ApplicationApiKeys disable response."""

    code: int
    success: bool
    message: Optional[str] = None
    item: Optional[ApplicationApiKeys] = None


class ApplicationApiKeysGetResponse(BaseModel):
    """ApplicationApiKeys get response."""

    code: int
    success: bool
    message: Optional[str] = None
    item: Optional[ApplicationApiKeys] = None


class ApplicationApiKeysListResponse(BaseModel):
    """ApplicationApiKeys list response."""

    code: int
    success: bool
    message: Optional[str] = None
    items: Optional[List[ApplicationApiKeys]] = None
    next_token: Optional[str] = None
