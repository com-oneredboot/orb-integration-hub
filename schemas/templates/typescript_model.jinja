/**
 * Generated TypeScript models for {{ schema.name }}
 * Generated at {{ timestamp }}
 */

// Import enums and models used in this model
{% for enum in enum_imports %}
import { {{ enum }} } from './{{ enum }}.enum';
{% endfor %}
{% for model in model_imports %}
import { {{ model }} } from './{{ model }}.model';
{% endfor %}

{% if schema.type == 'table' %}
// CreateInput
export type {{ schema.table }}CreateInput = {
{% for attr in schema.attributes %}
  {{ attr.name }}: {{ attr.type }}{% if not attr.required %} | undefined{% endif %};
{% endfor %}
};

// UpdateInput
export type {{ schema.table }}UpdateInput = {
{% for attr in schema.attributes %}
  {{ attr.name }}: {{ attr.type }}{% if not attr.required %} | undefined{% endif %};
{% endfor %}
};

// QueryInput
export type {{ schema.table }}QueryBy{{ schema.partition_key|to_pascal_case }}Input = {
  {{ schema.partition_key }}: string;
};

{% if schema.sort_key and schema.sort_key != 'None' %}
export type {{ schema.table }}QueryBy{{ schema.sort_key|to_pascal_case }}Input = {
  {{ schema.sort_key }}: string;
};

export type {{ schema.table }}QueryByBothInput = {
  {{ schema.partition_key }}: string;
  {{ schema.sort_key }}: string;
};
{% endif %}

{% for index in schema.secondary_indexes %}
export type {{ schema.table }}QueryBy{{ index.partition|to_pascal_case }}Input = {
  {{ index.partition }}: string;
};
{% endfor %}

// Response types
export type {{ schema.table }}Response = {
  statusCode: number;
  message: string;
  data: I{{ schema.table }} | null;
};

export type {{ schema.table }}CreateResponse = {
  statusCode: number;
  message: string;
  data: I{{ schema.table }} | null;
};

export type {{ schema.table }}UpdateResponse = {
  statusCode: number;
  message: string;
  data: I{{ schema.table }} | null;
};
{% endif %}

// Input types
export interface {{ schema.name }}CreateInput {
{% for attr in schema.attributes %}
  {{ attr.name }}: {{ attr.type|to_typescript_type }};
{% endfor %}
}

export interface {{ schema.name }}UpdateInput {
{% for attr in schema.attributes %}
  {{ attr.name }}?: {{ attr.type|to_typescript_type }};
{% endfor %}
}

// Always include DeleteInput (PK fields only)
export interface {{ schema.name }}DeleteInput {
  {{ schema.partition_key }}: string;
{% if schema.sort_key and schema.sort_key != 'None' %}  {{ schema.sort_key }}: string;
{% endif %}}

// Always include DisableInput (PK fields + disabled boolean)
export interface {{ schema.name }}DisableInput {
  {{ schema.partition_key }}: string;
{% if schema.sort_key and schema.sort_key != 'None' %}  {{ schema.sort_key }}: string;
{% endif %}  disabled: boolean;
}

// QueryBy inputs for PK, SK, and all indexes
export interface {{ schema.name }}QueryBy{{ schema.partition_key|to_pascal_case }}Input {
  {{ schema.partition_key }}: string;
}
{% if schema.sort_key and schema.sort_key != 'None' %}
export interface {{ schema.name }}QueryBy{{ schema.sort_key|to_pascal_case }}Input {
  {{ schema.sort_key }}: string;
}
export interface {{ schema.name }}QueryByBothInput {
  {{ schema.partition_key }}: string;
  {{ schema.sort_key }}: string;
}
{% endif %}
{% for index in schema.secondary_indexes %}
export interface {{ schema.name }}QueryBy{{ index.partition|to_pascal_case }}Input {
  {{ index.partition }}: string;
}
{% endfor %}

// DTO Interface (API/DB contract)
export interface I{{ schema.name }} {
{% for attr in schema.attributes %}
  {{ attr.name }}: string{% if attr.type|to_typescript_type == 'string[]' %}[]{% elif attr.type|to_typescript_type == 'number' %} | number{% elif attr.type|to_typescript_type == 'boolean' %} | boolean{% endif %};
{% endfor %}
}

// Domain Model Class (uses enums for enum fields)
// Properties: '!' = required (definite assignment), '?' = optional (from schema)
export class {{ schema.name }} {
{% for attr in schema.attributes %}
  {{ attr.name }}{% if not attr.required %}?{% else %}!{% endif %}: {% if attr.enum_type %}{{ attr.enum_type }}{% else %}{{ attr.type|to_typescript_type }}{% endif %};
{% endfor %}

  constructor(data: Partial<{{ schema.name }}> = {}) {
    Object.assign(this, data);
  }

  // Convert from DTO (I{{ schema.name }}) to domain model
  static fromDto(dto: I{{ schema.name }}): {{ schema.name }} {
    return new {{ schema.name }}({
{% for attr in schema.attributes %}
      {{ attr.name }}: {% if attr.enum_type %}{{ attr.enum_type }}[dto.{{ attr.name }} as keyof typeof {{ attr.enum_type }}] ?? {{ attr.enum_type }}.UNKNOWN{% else %}dto.{{ attr.name }}{% endif %},
{% endfor %}
    });
  }

  // Convert domain model to DTO (I{{ schema.name }})
  toDto(): I{{ schema.name }} {
    return {
{% for attr in schema.attributes %}
      {{ attr.name }}: {% if attr.enum_type %}this.{{ attr.name }}.toString(){% else %}this.{{ attr.name }}{% endif %},
{% endfor %}
    };
  }
}

{% if schema.enums %}
{% for enum_name, enum_values in schema.enums.items() %}
export enum {{ enum_name }} {
  {% for value in enum_values %}
  {{ value }} = '{{ value }}',
  {% endfor %}
}
{% endfor %}
{% endif %}

// ProperCase response types
export interface {{ schema.name }}Response {
  StatusCode: number;
  Message: string;
  Data: {{ schema.name }};
}

export interface {{ schema.name }}ListResponse {
  StatusCode: number;
  Message: string;
  Data: {{ schema.name }}[];
}

// CRUD response aliases
export type {{ schema.name }}CreateResponse = {{ schema.name }}Response;
export type {{ schema.name }}UpdateResponse = {{ schema.name }}Response;
export type {{ schema.name }}DeleteResponse = {{ schema.name }}Response;
export type {{ schema.name }}DisableResponse = {{ schema.name }}Response;
